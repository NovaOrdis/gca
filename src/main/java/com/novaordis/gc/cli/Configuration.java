package com.novaordis.gc.cli;

import com.novaordis.gc.UserErrorException;
import com.novaordis.gc.cli.command.InfoCommand;
import org.apache.log4j.Logger;

import java.io.File;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.Iterator;

/**
 * @author <a href="mailto:ovidiu@novaordis.com">Ovidiu Feodorov</a>
 *
 * Copyright 2013 Nova Ordis LLC
 */
public class Configuration
{
    // Constants -------------------------------------------------------------------------------------------------------

    private static final Logger log = Logger.getLogger(Configuration.class);

    public static final String VERSION = "1.1.7-SNAPSHOT";

    public static final String COMMAND_LINE_TIME_ORIGIN_SPEC = "MM/dd/yy HH:mm:ss";
    public static final SimpleDateFormat COMMAND_LINE_TIME_ORIGIN_FORMAT =
        new SimpleDateFormat(COMMAND_LINE_TIME_ORIGIN_SPEC);

    public static final String COMMAND_LINE_TIME_ORIGIN_SPEC2 = "MM/dd/yy HH:mm:ss,SSS";
    public static final SimpleDateFormat COMMAND_LINE_TIME_ORIGIN_FORMAT2 =
        new SimpleDateFormat(COMMAND_LINE_TIME_ORIGIN_SPEC2);


    public static final String[] FILE_NAME_TIME_ORIGIN_SPEC = new String[]
        {
            "dd-MMM-yy-HHmmss",      // 28-Dec-11-200855
            "dd-MMM-yy-HHmm",        // 28-Dec-11-2008
            "MM-dd-yyyy_HH-mm-ss",   // 08-28-2013_13-14-31 (and xxx.log-08-28-2013_13-14-31)
            "ddMMMyyHHmmss"          // 24Apr15130823
        };

    public static final SimpleDateFormat[] FILE_NAME_TIME_ORIGIN_FORMAT =
        new SimpleDateFormat[FILE_NAME_TIME_ORIGIN_SPEC.length];

    static
    {
        for(int i = 0; i < FILE_NAME_TIME_ORIGIN_SPEC.length; i ++)
        {
            FILE_NAME_TIME_ORIGIN_FORMAT[i] = new SimpleDateFormat(FILE_NAME_TIME_ORIGIN_SPEC[i]);
        }
    }

    public static final SimpleDateFormat TIMESTAMP_DISPLAY_FORMAT = new SimpleDateFormat("MM/dd/yy hh:mm:ss.SSS a");
    public static final DecimalFormat DURATION_SECONDS_FORMAT = new DecimalFormat("####.000");
    public static final DecimalFormat PERCENTAGE_FORMAT = new DecimalFormat("#.00");
    public static final DecimalFormat MEMORY_FORMAT = new DecimalFormat("#.0");
    public static final DecimalFormat DOUBLE_TWO_DIGITS_AFTER_DECIMAL_SEPARATOR = new DecimalFormat("#0.00");


    // Static ------------------------------------------------------------------------------------------------------------------------------

    // Attributes --------------------------------------------------------------------------------------------------------------------------

    private File gcLogFile;
    private Long timeOrigin;
    private Command command;
    private boolean suppressTimestampWarning;

    // Constructors ------------------------------------------------------------------------------------------------------------------------

    public Configuration(String[] args) throws Exception
    {
        parseCommandLine(args);

        if (command == null)
        {
            // if we have a target file, then we used the default command, otherwise we just return
            if (gcLogFile == null)
            {
                return;
            }

            command = new InfoCommand(this, null);

        }

        inferConfiguration();

        validateGlobalParameters();

        log.debug(this + " created");
    }

    // Public ------------------------------------------------------------------------------------------------------------------------------

    /**
     * If there is no command, we get null.
     */
    public Command getCommand()
    {
        return command;
    }

    /**
     * The configuration implementation insures that a returned file exists on disk and it's readable. It does not insure the file has a
     * correct format.
     *
     * @return the garbage collection log file, as generated by the JVM.
     */
    public File getGCLogFile()
    {
        return gcLogFile;
    }

    public Long getTimeOrigin()
    {
        return timeOrigin;
    }

    public boolean isSuppressTimestampWarning()
    {
        return suppressTimestampWarning;
    }

    // Package protected -----------------------------------------------------------------------------------------------

    /**
     * Package protection exposure for testing.
     */
    static long toTimeOrigin(String s) throws UserErrorException
    {
        // attempt to convert - if we encounter and error or get null, we complain

        Date d = null;

        try
        {
            d = COMMAND_LINE_TIME_ORIGIN_FORMAT2.parse(s);

        }
        catch(Exception e)
        {
            // attempt the second format

            try
            {
                d = COMMAND_LINE_TIME_ORIGIN_FORMAT.parse(s);
            }
            catch(Exception e2)
            {
                throw new UserErrorException("time origin '" + s + "' not in expected format (" + COMMAND_LINE_TIME_ORIGIN_SPEC + ", " + COMMAND_LINE_TIME_ORIGIN_SPEC2 + ")", e2);
            }
        }

        if (d == null)
        {
            throw new IllegalStateException("conversion returns null");
        }

        return d.getTime();
    }

    /**
     * Package protection exposure for testing.
     *
     * @return null if no meaningful time origin can be extracted from the file name.
     */
    static Long fileNameToTimeOrigin(String fileName) throws UserErrorException
    {
        if (fileName == null)
        {
            return null;
        }

        // we expect to find the time origin information after the last dot

        int p = fileName.lastIndexOf(".");

        if (p == -1)
        {
            return null;
        }

        String candidateTs = fileName.substring(p + 1);

        // garbage_collection.log-08-28-2013_13-14-31 case, we have log-08... after the last dot
        if (candidateTs.matches("^[a-zA-Z_]+-.+"))
        {
            candidateTs = candidateTs.replaceFirst("[a-zA-Z_]+-", "");
        }

        for(int i = 0; i < FILE_NAME_TIME_ORIGIN_SPEC.length; i ++)
        {
            try
            {
                Date d = FILE_NAME_TIME_ORIGIN_FORMAT[i].parse(candidateTs);

                if (d != null)
                {
                    return d.getTime();
                }
            }
            catch(Exception e)
            {
                // just ignore, it simply means the format does not apply
            }

        }

        return null;
    }

    // Protected ---------------------------------------------------------------------------------------------------------------------------

    // Private -----------------------------------------------------------------------------------------------------------------------------

    private void parseCommandLine(String[] args) throws Exception
    {
        Iterator<String> i = Arrays.asList(args).iterator();

        while(i.hasNext())
        {
            String crt = i.next();

            if (command == null)
            {
                command = CommandFactory.getCommand(crt, i, this);

                if (command != null)
                {
                    continue;
                }
            }

            if ("--time-origin".equals(crt) || "-t".equals(crt))
            {
                // we expect a time stamp as the next token

                if (!i.hasNext())
                {
                    throw new UserErrorException("a time stamp should follow " + crt);
                }

                String tos = i.next();

                if (tos.matches("\\d\\d/\\d\\d/\\d\\d"))
                {
                    // very likely that a full timestamp follows but the upper shell did break it down into two separate tokens, so
                    // also append the next token

                    if (!i.hasNext())
                    {
                        throw new UserErrorException(
                            "a time stamp should follow " + crt + " but it seems that only the first part of the time stamp (" +
                                tos + ") was provided");
                    }

                    tos += " ";
                    tos += i.next();
                }

                timeOrigin = toTimeOrigin(tos);
            }
            else if ("--suppress-timestamp-warning".equals(crt))
            {
                suppressTimestampWarning=true;
            }
            else if (crt.startsWith("--"))
            {
                throw new UserErrorException("unknown global option " + crt);
            }
            else if (gcLogFile == null)
            {
                gcLogFile = new File(crt);
            }
            else
            {
                // we're not handling this command line argument, fail because the user might think it's used while it is not
                throw new UserErrorException("command line argument \"" + crt + "\" does not makes sense in the location it was specified");
            }
        }
    }

    private void validateGlobalParameters() throws UserErrorException
    {
        if (!command.needsGcData())
        {
            // nothing to validate
            return;
        }

        if (gcLogFile == null)
        {
            throw new UserErrorException("no GC log file specified");
        }

        if (!gcLogFile.isFile() || !gcLogFile.canRead())
        {
            throw new UserErrorException("GC log file " + gcLogFile + " does not exist or cannot be read");
        }

        // the command will parse the file, and there is a chance we'll find timestamps inside, so don't complain about missing timestamps
        // yet
    }

    private void inferConfiguration() throws UserErrorException
    {
        if (command.needsGcData() && gcLogFile != null && timeOrigin == null)
        {
            // try to infer the time origin form the file name, but it's fine if we can't, the file might contain the time stamps
            timeOrigin = fileNameToTimeOrigin(gcLogFile.getName());
        }
    }

    // Inner classes -----------------------------------------------------------------------------------------------------------------------
}



