#!/bin/bash
#
# Standard bash shell functions
#


# display the error message at stderr and exist with a value equal with the second argument. If the second argument is not present,
# exit with 1
function fail()
{
    error_message=$1
    exit_value=$2;

    [ "${exit_value}" = "" ] && exit_value=1

    [ "${debug}" != "" ] && ${debug} && debug_info=" $0 ${FUNCNAME[1]}:"

    echo "" 1>&2;
    echo "[ERROR]:${debug_info} ${error_message}" 1>&2;
    echo "" 1>&2;

    exit ${exit_value}
}

# display the error message at stderr
function error()
{
    error_message=$1

    [ "${debug}" != "" ] && ${debug} && debug_info=" $0 ${FUNCNAME[1]}:"

    echo "" 1>&2;
    echo "[ERROR]:${debug_info} ${error_message}" 1>&2;
    echo "" 1>&2;
}

# display a warning message at stderr
function warn()
{
    message=$1

    [ "${debug}" != "" ] && ${debug} && debug_info=" $0 ${FUNCNAME[1]}:"

    echo "[WARNING]:${debug_info} ${message}" 1>&2;
}

# display the info message at stderr
function info()
{
    echo "$1" 1>&2;
}

# display the debug message at stderr but only if debug flag is set
function debug()
{
    if [ "${debug}" = "" ] || ! ${debug}; then return; fi

    effective_user=`get_user_name` || exit 1

    ${debug} && echo "$0 ${effective_user}@${FUNCNAME[1]}: $1" 1>&2;
}

# dumps the function's arguments - identical with debug_args_no_nl below, except nl
function debug_args()
{
    if [ "${debug}" = "" ] || ! ${debug}; then return; fi

    effective_user=`get_user_name` || exit 1

    echo -n "$0 ${effective_user}@${FUNCNAME[1]}(" 1>&2;
    while [ $# -gt 0 ]; do
        [ "$1" = "" ] && echo -n "\"\"" 1>&2 || echo -n $1 1>&2
        shift
        [ $# -gt 0 ] && echo -n ", " 1>&2
    done
    echo ")" 1>&2;
}

# dumps the function's arguments - identical with debug_args above, except nl
function debug_args_no_nl()
{
    [ "${debug}" = "" ] && return

    ! ${debug} && return

    effective_user=`get_user_name` || exit 1

    echo -n "$0 ${effective_user}@${FUNCNAME[1]}(" 1>&2;
    while [ $# -gt 0 ]; do
        [ "$1" = "" ] && echo -n "\"\"" 1>&2 || echo -n $1 1>&2
        shift
        [ $# -gt 0 ] && echo -n ", " 1>&2
    done
    echo -n ") " 1>&2;
}

# returns the MD5 has of the given string at stdout
function md5hash()
{
    cleartext=$1

    [ "${cleartext}" = "" ] && fail "$0.md5hash: must specify the clear text string as argument"

    echo -n "${cleartext}" | openssl dgst -md5 -binary | openssl base64
}

# fail if the current user does not have the specified user id. root always has user id 0.
function insure_user()
{
    user_id=$1

    debug "$0.insure_user(${user_id})"

    [ "${user_id}" = "" ] && fail "$0.insure_user: 'user_id' not provided"

    effective_user_id=`id -u` || fail "$0.insure_user: cannot get effective user id"

    [ ${user_id} -eq ${effective_user_id} ] && return;

    [ ${user_id} -eq 0 ] && message="root" || message="an user with the effective user id ${user_id}"

    fail "this script must be run by ${message}"
}

function insure_root()
{
    insure_user 0
}

# send the current user name at stdout or fail
function get_user_name()
{
    id -un || fail "failed to get the effective user name"
}

function comma_separated_list_to_space_separated()
{
    echo ${1//,/ }
}

#
# returns an unique temporary file name at stdout - does not create the file, does not delete it
#
function get_unique_temporary_file_name()
{
    echo "/tmp/ec-"`date +'%y%m%d%H%M%S'`"${RANDOM}.tmp"
}

#
# back up the given file or fail if backup cannot be completed
#
function backup()
{
    file_to_back_up=$1

    [ "${file_to_back_up}" != "" ] || fail "'file_to_back_up' not specified"
    [ -f ${file_to_back_up} ] || fail "file to back up ${file_to_back_up} does not exist"

    backup_file="${file_to_back_up}."`date +'%y%m%d.%H%M%S'`".ec-backup"

    # copy will fail if the destination file exists
    [ -f ${backup_file} ] && fail "failed to back up ${file_to_back_up}, destination file ${backup_file} exists"

    cp ${file_to_back_up} ${backup_file} && info "backed up ${file_to_back_up} as ${backup_file}" || fail "failed to back up ${file_to_back_up}"
}


#
# stdouts a negative integer if t1 is strictly smaller than t2, 0 if the timestamps are equal and a positive integer if t1 is strictly
# bigger than t2. The for the time being timestamps must be in the "yyyy-mm-dd HH:MM:ss" format
#
function compare_timestamps()
{
    t1=$1
    t2=$2

    debug_args "${t1}" "${t2}"

    mt1=${t1//[-:]/ }
    read y1 m1 d1 H1 M1 s1 <<< ${mt1}
    debug "y1=${y1} m1=${m1} d1=${d1} H1=${H1} M1=${M1} s1=${s1}"
    mt2=${t2//[-:]/ }
    read y2 m2 d2 H2 M2 s2 <<< ${mt2}
    debug "y2=${y2} m2=${m2} d2=${d2} H2=${H2} M2=${M2} s2=${s2}"

    [ "${y1}" != "" ] || fail "year not specified in first timestamp '${t1}'"
    [ "${m1}" != "" ] || fail "month not specified in first timestamp '${t1}'"
    [ "${d1}" != "" ] || fail "day not specified in first timestamp '${t1}'"
    [ "${H1}" != "" ] || fail "hour not specified in first timestamp '${t1}'"
    [ "${M1}" != "" ] || fail "minute not specified in first timestamp '${t1}'"
    [ "${s1}" != "" ] || fail "second not specified in first timestamp '${t1}'"

    [ "${y2}" != "" ] || fail "year not specified in second timestamp '${t2}'"
    [ "${m2}" != "" ] || fail "month not specified in second timestamp '${t2}'"
    [ "${d2}" != "" ] || fail "day not specified in second timestamp '${t2}'"
    [ "${H2}" != "" ] || fail "hour not specified in second timestamp '${t2}'"
    [ "${M2}" != "" ] || fail "minute not specified in second timestamp '${t2}'"
    [ "${s2}" != "" ] || fail "second not specified in second timestamp '${t2}'"

    if [ ${y1} -lt ${y2} ]; then
        echo -1
    elif [ ${y1} -gt ${y2} ]; then
        echo 1
    else
        if [ ${m1} -lt ${m2} ]; then
            echo -1
        elif [ ${m1} -gt ${m2} ]; then
            echo 1
        else
            if [ ${d1} -lt ${d2} ]; then
               echo -1
            elif [ ${d1} -gt ${d2} ]; then
                echo 1
            else
                if [ ${H1} -lt ${H2} ]; then
                    echo -1
                elif [ ${H1} -gt ${H2} ]; then
                    echo 1
                else
                    if [ ${M1} -lt ${M2} ]; then
                       echo -1
                    elif [ ${M1} -gt ${M2} ]; then
                       echo 1
                    else
                        if [ ${s1} -lt ${s2} ]; then
                            echo -1
                        elif [ ${s1} -gt ${s2} ]; then
                            echo 1
                        else
                            echo 0
                        fi
                    fi
                fi
            fi
        fi
    fi
}

#
# returns the difference in seconds between t1 and t2 (t2 - t1)
# both timestamps are supposed to be in "yyyy-mm-dd HH:MM:ss" format
#
function delta_in_seconds()
{
    t1=$1
    t2=$2

    debug_args "${t1}" "${t2}"

    mt1=${t1//[-:]/ }
    read y1 m1 d1 H1 M1 s1 <<< ${mt1}
    debug "y1=${y1} m1=${m1} d1=${d1} H1=${H1} M1=${M1} s1=${s1}"
    mt2=${t2//[-:]/ }
    read y2 m2 d2 H2 M2 s2 <<< ${mt2}
    debug "y2=${y2} m2=${m2} d2=${d2} H2=${H2} M2=${M2} s2=${s2}"

    [ "${y1}" != "" ] || fail "year not specified in first timestamp '${t1}'"
    [ "${m1}" != "" ] || fail "month not specified in first timestamp '${t1}'"
    [ "${d1}" != "" ] || fail "day not specified in first timestamp '${t1}'"
    [ "${H1}" != "" ] || fail "hour not specified in first timestamp '${t1}'"
    [ "${M1}" != "" ] || fail "minute not specified in first timestamp '${t1}'"
    [ "${s1}" != "" ] || fail "second not specified in first timestamp '${t1}'"

    [ "${y2}" != "" ] || fail "year not specified in second timestamp '${t2}'"
    [ "${m2}" != "" ] || fail "month not specified in second timestamp '${t2}'"
    [ "${d2}" != "" ] || fail "day not specified in second timestamp '${t2}'"
    [ "${H2}" != "" ] || fail "hour not specified in second timestamp '${t2}'"
    [ "${M2}" != "" ] || fail "minute not specified in second timestamp '${t2}'"
    [ "${s2}" != "" ] || fail "second not specified in second timestamp '${t2}'"

    if [ "${t1}" = "${t2}" ]; then
        echo 0
        return;
    fi

    # incomplete implementation, should be good enough for our purposes
    [ "${y1}" != "${y2}" ] && fail "delta between different years (${t1}, ${t2}) not implemented yet"
    [ "${m1}" != "${m2}" ] && fail "delta between different months (${t1}, ${t2}) not implemented yet"

    aggregated1=`expr ${d1} \* 86400`
    aggregated1=`expr ${aggregated1} + ${H1} \* 3600`
    aggregated1=`expr ${aggregated1} + ${M1} \* 60`
    aggregated1=`expr ${aggregated1} + ${s1}`

    aggregated2=`expr ${d2} \* 86400`
    aggregated2=`expr ${aggregated2} + ${H2} \* 3600`
    aggregated2=`expr ${aggregated2} + ${M2} \* 60`
    aggregated2=`expr ${aggregated2} + ${s2}`

    debug "aggregated1: ${aggregated1}, aggregated2: ${aggregated2}"

    expr ${aggregated2} - ${aggregated1}
}